1. Big-O notation expresses the performance behavior of an algorithm. The algorithm might take as an input a number, n, or, more commonly, a data structure of size n. (If there is more than one input, or the input has multiple dimensions, we need to specify the one we are considering.) We then measure the time or number of operations required to execute the algorithm as a function of n. If that time increases linearly with n, so that doubling n roughly doubles the time, we say that the algorithm is O(n). If, on the other hand, the time increases with the square of n, so that doubling n roughly quadruples the time, then the algorithm is O(nÂ²).

2. Quicksort is an excellent algorithm for sorting an array. It works recursively, although the recursion can be unrolled using a stack. The main idea is that at each step we pick an element and then scan through the array (from both ends at once), swapping elements as needed so that the array is partitioned with all of the elements less than the chosen element together at the lower end and all of the elements greater than the chosen element at the upper end. At the end of this partitioning step, the chosen element is in its rightful place. Then we repeat the process separately for the two sublists on either side of that element. The recursion stops when the sublists have only one element.

3. A pointer in C is a variable which contains the address of a location in memory. This can be the address of another variable. For example if we have an integer variable declared as:
int i = 4;
then the value of i is stored at some location in memory. We can then declare a pointer variable
int * p = &i;
This variable then holds the address of i. C allows pointers to arbitrary places in memory, however, so that, for example, a pointer can be set to point to an offset into a buffer of data. Used carefully, this is a powerful tool. Used carelessly, it is a dangerous one.

4. In most programming languages, notably C and C++, each thread of execution has a fixed block of memory assigned as the Stack (a.k.a. "call stack"). It is organized as a LIFO stack and used to hold the parameters and local variables for each function that is called. It also has space for the return value of the function and the instruction pointer to jump to when the function returns. The current function's data is at the top of the stack; that of the function that called it, just below; and so on all the way down to main(). All of this is managed pretty much automatically.
The remaining memory available to the program is Heap memory and this is managed more directly by the programmer. In C such memory is often directly allocated (with malloc() or the equivalent) and must be released manually (with free()) when it is no longer needed. In C++, Heap memory is usually obtained through calls to new(). Such calls need to be paired with calls to delete(), though modern programming techniques (shared_ptr, vector, etc.) allow this to be done automatically. In these languages, variables on the Heap are accessed via pointers.

5. A garbage collector automates the release of Heap memory that is no longer in use. Unlike C and C++, languages such as Java, C#, as well as most scripting languages do not provide free() or delete() functions. Instead they track all references to objects. Periodically and/or when free memory runs low, they run a garbage collector which identifies Heap objects that are no longer referred to by any active variables. (That is, the functions that used the objects have terminated.) This Heap memory is released for reuse.
