First of all, to run the Sudoku solver program, from the sudoku directory, run
bin/solve < [test file]
There is a CSV file called littlebook190.csv in the test directory, so you can run
bin/solve < test/littlebook190.csv
(It is puzzle 190 from Will Shortz's Little Book of Lots of Sudoku.)
You can also run the unit tests:
ruby test/test_puzzle.rb
ruby test/test_solver.rb


The Sudoku solver presented here uses three approaches to filling in the blanks in a puzzle.
1) The first, solve_by_blank_possibilities, determines, for each blank, which values are possible, i.e. not excluded by their presence in the same row, column, or block. It then looks for a blank where exactly one value is possible.
2) The next, tried if the first fails, is solve_by_rcb_possibilities. This algorithm goes through each row, then each column, then each block (hence "rcb"). In each such group it looks at the possibilities identified for the blanks in that group. For each blank, it determines values that are possible for that blank but not for any of the other blanks in the group. It looks for a blank where exactly one value is only possible there.
3) If these fail, I resort to solve_by_brute_force. This approach looks for a blank with the minimum number of possibilities. Then for each of these possible values for that blank, it creates a puzzle with that value entered and tries to solve the puzzle. (This is a recursive call and the solver for that puzzle will try all of the algorithms in the same order.) In a well-formed puzzle exactly one value will allow for a solution, and the rest of the solution will have been determined in the process.

For a puzzle with rows, columns, and blocks of size N (where N is usually 9), a large fraction of the cells are typically blank at the start, so there are on the O(N^2) blanks to be filled in. Each step in the solver fills in one blank.
The first approach iterates over the blanks. For each one it computes the set intersection of three arrays. Each of these sets contains on the order of N elements (the values missing in a group). I'm not sure what Ruby's intersection algorithm does, but it may involve a sort, which is O(N log N). So each step is O(N^3 log N).
The second approach iterates over the 3N = O(N) groups, and then over the O(N) blanks in each group. For each blank it computes the set difference with the other O(N) blanks in the group. Again set difference may be O(N log N). So each step is O(N^4 log N).
The brute-force approach is potentially onerous. In principle we have to consider the O(N) possibilities for each of the O(N^2) blanks. While it is likely that most of these examinations terminate quickly, it is not obvious that the order of this algorithm on its own is better than O(N^(N^2)).
The good news is that in my experiments with actual puzzles, the first approach fills in most of the blanks, followed by the second. When I tested an "light and easy" puzzle from one of Will Shortz's books, it could be solved exclusively using the first algorithm. A "moderate" puzzle required occasional use of the second. A "demanding" puzzle required one call to solve_by_brute_force, and a "beware! very challenging" puzzle required three.
So actual performance is probably closer to O(N^5 log N) than to O(N^6 log N). Since N is actually rather small, the solver proves to be pretty quick.

About eight years ago I worked my way through a book of Sudoku to see what the fuss was about. I found that while there were occasional new insights along the way, most of the work consisted of devising concise forms of bookkeeping to track the possibilities that had not yet been eliminated. It seemed like a job better suited to a computer, and I've always had the idea in the back of my mind that someday I ought to write a program that implements just that bookkeeping and logic. With this homework, my opportunity arrived. But of course by now I'm rather rusty, so I just remembered the basic techniques, and those are what I implemented. These algorithms are, in other words, my version of how a human (me) solves Sudoku. (I confess that near the end of that book I did in fact resort a few times to the brute-force approach, proving by contradiction that all but one value could fill some blank. I always felt ashamed of this.)

It is entirely possible that there are completely different approaches, or a single over-arching algorithm, that are simpler and faster than this. I used Google on occasion in doing this homework, mostly to learn a few things about Ruby, but I studiously avoided looking for any Sudoku algorithms.

I do also have another trick or two up my sleeve. For example, one technique I recall involves groups where a pair of blanks each have the same pair of possibilities. (E.g. in some row two blanks can each only be 3 or 5.) This allows those values to be eliminated as possibilities for the other blanks in that group. (E.g., no other blank in that row can be 3 or 5.) It wouldn't be hard to add that consideration, but I ran out of time. Also, in anticipation of possible future use, I not only track the values that are missing in each group, but also those that are present. I never used the latter data in my algorithms, but I put that tracking in because it's pretty cheap and may be useful later on. I also keep a record of entries as they are determined. That wasn't necessary for this assignment, but is helpful for debugging and profiling and could also be useful in a different UI context.

This was my first Ruby program, so I am certain that as I learn more I will discover much better ways of doing some of the things I did here. One little decision I made was to use Arrays where Sets might have seemed more natural. I did so mainly because I needed a method to pop the last value from a set of possible values and didn't see how to do that neatly with Set. (It could be done using each() and delete(), I'm sure, but that seems ugly, and it's already clear that anything ugly is not good Ruby.)
